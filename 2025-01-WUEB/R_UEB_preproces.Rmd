---
title: "![IR](images/Logo_VHIR_HUVH_blanco_fondo_lila_JMC_2.png){ width=80% }![UEB](images/logo_UEB_lletres_blanc.png){ width=80% }  <br><br> Manual UEB estudis estadística"
author: 
    - name: "Miriam Mota-Foix <br> ueb@vhir.org"
date: "`r format(Sys.time(), '%d %B, %Y')`" 
css: Rcode/custom.css
# https://bookdown.org/yihui/rmarkdown/html-document.html#custom_css
output:
  rmdformats::readthedown:
    # code_folding: hide
    thumbnails: false
    lightbox: true
    gallery: true
    highlight: tango
    mathjax: "rmdformats"
    theme: flatly
    toc_depth: 3
    number_sections: yes
    fig_caption: TRUE
    use_bookdown: true
    df_print: paged
    # keep_md: yes
    code_download: yes
    includes:
      # in_header: header.html
      # before_body: doc_prefix.html
      after_body: Rcode/footer.html
---

<head>
  <script type="text/javascript">
    var password = "MainHead"; // Cambia 'miContraseña' por la contraseña que prefieras
    var pass = prompt("Introduce la contraseña:");
    if (pass != password) {
      window.location = "about:blank"; // Si la contraseña es incorrecta, redirige a una página en blanco
    }
  </script>
</head>



```{r, echo = FALSE, results = 'hide', message = F}
require(knitr)
# include this code chunk as-is to set options
opts_chunk$set(ommcent = NA, prompt = FALSE, tidy = FALSE, fig.width = 7, fig.height = 7,echo = TRUE, message = FALSE, warning = FALSE, eval = F)
Sys.setlocale("LC_TIME", "C")
```


```{r,echo=FALSE}
library(tidyverse)

set.seed(123) # Para reproducibilidad

n <- 1000 # Número de pacientes

data <- tibble(
  patient_id = 1:n,
  age = rnorm(n, mean = 50, sd = 15),
  sex = sample(c("M", "F", "m", "f", "Male", "Female", ""), n, replace = TRUE),
  bmi = rnorm(n, mean = 25, sd = 5),
  smoker = sample(c(0, 1), n, replace = TRUE),
  diabetes = sample(c(0, 1, "Yes", "No", "Y", "N", "se ha"), n, replace = TRUE),
  blood_pressure = rnorm(n, mean = 120, sd = 15),
  cholesterol = rnorm(n, mean = 200, sd = 40),
  treatment = sample(c("A", "B", "C"), n, replace = TRUE),
  hospital = sample(c("Hospital 1", "Hospital 2", "Unknown"), n, replace = TRUE),
  followup_time = runif(n, 0, 60),
  event = sample(c(0, 1, "Yes", "No", ""), n, replace = TRUE),
  quality_of_life = rnorm(n, mean = 70, sd = 15)
)

# Introducir algunos errores y valores atípicos
data <- data %>%
  mutate(
    age = ifelse(runif(n) < 0.01, sample(c(-5, 150, 999, NA), n, replace = TRUE), age),
    bmi = ifelse(runif(n) < 0.01, sample(c(0, 100, "obese", NA), n, replace = TRUE), bmi),
    blood_pressure = ifelse(runif(n) < 0.01, sample(c(0, 300, "high", NA), n, replace = TRUE), blood_pressure),
    cholesterol = ifelse(runif(n) < 0.01, sample(c(0, 1000, "elevated", NA), n, replace = TRUE), cholesterol),
    followup_time = ifelse(runif(n) < 0.01, sample(c(-10, 100, "ongoing", NA), n, replace = TRUE), followup_time),
    quality_of_life = ifelse(runif(n) < 0.01, sample(c(-10, 110, "good", NA), n, replace = TRUE), quality_of_life)
  ) %>% 
  mutate(patient_id = as.numeric(patient_id))

dat <- data %>% as.data.frame()
Hmisc::label(dat, self = F) <- paste0("HMISClabel",names(dat))

rm(data)
```





**Este documento sirve como una guía paso a paso para la lectura y el preprocesamiento de datos en la realización de estudios estadísticos.En él se explica el proceso a seguir cuando los datos provienen de Redcap o de otros formatos, como Excel, así como las técnicas para la limpieza de los mismos.**

**El template preparado para utilizar esta en [Nuevo Equipo VHIR10 Dropbox\Miriam  Mota Foix\UEB-compartida\___UEB\Documents i Plantilles]("E:\39437789B\Documents\Nuevo Equipo VHIR10 Dropbox\Miriam  Mota Foix\UEB-compartida\___UEB\Documents i Plantilles\XXXX-nn-NomCognom-INSTITUT-ID-Informe.Rmd")**


# Paquetes R


## Instalación y carga

En la gran mayoria de los estudios necesitaremos una serie de paquetes: 

- **pacman** (para instalar y cargar paquetes) 
- **anaStatsUEB y mmotaF** para las funciones propias de la UEB.
- **rio** para cargar datos de casi cualquier formato
- **rmdformats** plantilla del rmarkdown

**Si es la primera vez que se usan, será necesario ejecutar las líneas de código que aparecen comentadas.**



```{r packages, eval=TRUE}
# install.packages("devtools")
# require(devtools)
# install_github("miriammota/mmotaF")
# install_github("uebvhir/anaStatsUEB")

require(anaStatsUEB)
require(mmotaF)
require(pacman)

p_load(rmdformats, rio)

```

## Descarga

Para tener la seguridad de que un estudio será facilmente reproducible en el futuro se puede ejecutar el siguiente código. Este código descarga los paquetes de R propios de la unidad en el momento de la ejecución del análisis. 


```{r}
p_load("downloader")
download("https://github.com/miriammota/mmotaF/archive/master.tar.gz", "mmotaF.tar.gz")
file.copy("mmotaF.tar.gz", paste0("hist/packages/mmotaF",Sys.Date(),".tar.gz"), overwrite = TRUE); file.remove("mmotaF.tar.gz")
download("https://github.com/uebvhir/anaStatsUEB/archive/master.tar.gz", "anaStatsUEB.tar.gz")
file.copy("anaStatsUEB.tar.gz", paste0("hist/packages/anaStatsUEB",Sys.Date(),".tar.gz"), overwrite = TRUE); file.remove("anaStatsUEB.tar.gz")
```


# Lectura de datos

En esta sección se explica cómo llevar a cabo la lectura de los datos y una limpieza inicial. 

## Excel, csv o similar


Para la lectura de datos se usa la función import del paquete rio. Es imprescindible indicar el nombre del archivo junto su extensión donde pone <span style="color:red"> **arxiu.extensio** </span>


El proceso de limpieza de datos inicial incluye o puede incluir las siguientes acciones:

1. **Almacenamiento de etiquetas "amigables"**: Facilita la interpretación de los datos mediante etiquetas claras y descriptivas.

2. **Limpieza de los nombres**: Normalización de los nombres de las variables, lo que implica convertir mayúsculas a minúsculas, eliminar símbolos, espacios innecesarios, etc. (Para más detalles, consultar la función ?clean_names).

3. [OPCIONAL]**Conversión de variables de tipo carácter a factor**: Transformar todas las variables de texto en factores para un manejo más eficiente en análisis estadísticos.

4. [OPCIONAL]**Asignación de valores NA**: Especificar un valor concreto (por ejemplo, un string) que debe ser tratado como dato faltante (NA) en toda la base de datos.

5. **Renombrado de la variable identificador**: Cambiar el nombre de la variable que contiene el identificador único a 'id' para facilitar su identificación y uso.


Este proceso asegura que los datos estén estructurados y preparados para su posterior análisis.

```{r}
dat <- import("dades/arxiu.extensio") ## LECTURA

## [[[[1]]]] 
Hmisc::label(dat,self = F)[Hmisc::label(dat) == ""] <- names(dat)[Hmisc::label(dat) == ""] ## En el cas de que la variable no tingui etiqueta assignem el nom de la variable com a etiqueta
lbls <- Hmisc::label(dat) ## Guardem els noms de les variables per utilitzar-los inmediatament després de la neteja

## [[[[2]]]]
dat <- janitor::clean_names(dat) 

## [[[[3 opcional]]]]
# dat <- dat %>% mutate_if(is.character, as.factor)

## [[[[4 opcional]]]]
# lbls <- Hmisc::label(dat)
# dat <- replace(dat, dat == "  ", NA)
# dat <- droplevels(dat) ##eliminem nivells buits

## [[[[5]]]]
dat %<>% rename(id = "nomdelidentificadorantic")

## [[[[1]]]] ## Retornem les etiquetes que s'han perdut en els passos previs 
Hmisc::label(dat, self = F) <- lbls 

```








## Redcap 

Acceder al proyecto de Redcap con el que se quiere trabajar y seguir los siguientes pasos 

- En el menú izquierdo: "Exportación de datos, Reportes y Estadísticas"  / "Todos los datos" / "Exportar Datos" / "Lenguaje de programación Estadístico R" / "Exportar Datos"
- Descargar los archivos R y csv.

Una vez descargados los datos: 

- Mover el script de R que se ha desargado a la carpeta principal
- Mover los datos en formato csv a la carpeta "dades"

<!-- ![](images/estructura.png){ width=43% }  -->


### Modificación script redcap
Para realizar la lectura de datos de Redcap correctamente es necesario corregir algunas líneas de código del script que se ha descargado de Redcap.

1. Substituir las 7 primeras líneas por:

```{r}
data = read.csv(file_loc)
```

  2. Ctrl + F (buscar y reemplazar), substituir todos los ".factor" por buit "".


  3.  Ctrl + F (buscar y reemplzçar), substituir todos los "label" por "Hmisc::label"


  4.  Ctrl + F (buscar y reemplazar), substituir todos los "Unchecked" por "No"


  5.  Ctrl + F (buscar y reemplazar), substituir todos los "Checked" por "Si"


  6.  Bajar todas las líneas de código referentes al etiquedao ( es decir, todas las líneas que empiezan con Hmisc::label al final del script)



### Lectura datos en informe

En el informe de análisis incluir un chunk con el siguiente código. 

Es imprescindible modificar la información de la variable <span style="color:red"> **nom_redcap y nom_script_redcap** </span>


Una vez ejecutado este código dispondremos de dos data.frames: 

- **dat_orig**: datos originales de Redcap una vez ejecutado el script. Este dataframe no se modificará en ningún momento ni será usado durante los análisis pero es util en caso de necesitar hacer alguna verificación de los datos. 

- **dat**: matriz de datos con la que trabajaremos para los análisis. Esta matriz de datos será donde limpiemos los datos, añadamos variables, etc. 

```{r, eval = F}
nom_redcap <- "NOM_del_projecte_com_ho_exporta_redcap_sense_la_data"
fitxers <- paste0("dades/",grep(nom_redcap, list.files("dades"),  fixed = T, value = T))
file_loc <- fitxers[file.info(fitxers)$ctime == max(file.info(fitxers)$ctime)]

nom_script_redcap <- grep(nom_redcap, list.files(),  fixed = T, value = T)
source(nom_script_redcap)
dat_orig <- data
dat <- data
rm(data)
```






# Pre-procesado de los datos


## Genérico


### Registro cambios

En el proceso de análisis de datos, es común necesitar modificar variables o realizar correcciones sobre ellas. Para mantener un registro detallado de estos cambios y facilitar su verificación por parte del equipo investigador, se ha desarrollado la función desc_changes.


<div  id="desc_changes" style="border: 1px solid #ddd; padding: 10px; border-radius: 5px; background-color: #d1ebd3;">
**desc_changes**

- **Propósito**: Documentar cambios inmediatamente después de realizarlos y mejorar la trazabilidiad

- **Funcionamiento**: Almacena una lista acumulativa de mensajes en el entorno de R.

- **Integración**: Las funciones propias var_to_num y factor_ueb incorporan automáticamente esta funcionalidad.


Se le puede cambiar el color al texto con el parámetro col. 

</div>



Para registrar información sobre los cambios realizados, se utiliza de la siguiente manera:


```{r,eval =TRUE}
var_sino <- c("Fum","hiper")
```

```{r, eval=TRUE}
desc_changes(paste0("Los valores, 0 y 1 se han considerado 'No' y 'Si' respectivamente para las variables: ", paste(var_sino,collapse = ", ") ))
desc_changes("Los valores superiores a 10000 para la variable n_il6_f han sido considerados NA ")
```

Para mostrar la lista formateada en HTML en el documento final, se debe utilizar el siguiente código:

```{r, results='asis',eval=TRUE}
list_changes %>%   walk(~ cat(.x, "\n"))
```



### Variables FECHA

Seleccionar las variables fecha en el vector "var_date". Con la función mutate_at se pueden convertir todas a la vez. 

<span style="color: red;">Es imprescindible verificar el formato o los formatos</span>

```{r}
var_date <- names(dat %>% select(contains("fecha")))
lbls <- Hmisc::label(dat[,var_date]) ## guardem etiquetes variables data
dat %<>%   mutate_at(vars(var_date), list(~as.Date(., "%Y-%m-%d")),.keep = all)
Hmisc::label(dat[,var_date],self = F) <- lbls  ## retornem etiquetes variables data
```



### Variables NUMERICO

Es común que, debido a algún problema durante la introducción de los datos, R haya interpretado como caracteres variables que deberían ser numéricas. Para solucionar esto, es necesario seleccionar todas las variables que se desean convertir a numéricas y almacenarlas en el vector llamado var_num. Este paso permite corregir la clase de las variables y asegurar que estén listas para su análisis.


Para la transformación de las variables se usa la función propia (paquete anaStatsUEB) var_to_num. 

<div id="var_to_num" style="width: 80%; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background-color: #d1ebd3;">
**var_to_num**

se utiliza para convertir una variable de tipo carácter en una variable numérica. 

Reemplaza las comas por puntos, elimina espacios y devuelve una variable numérica junto con una advertencia sobre los valores eliminados. La advertencia es guardada en list_changes.

</div>


```{r}
var_num <- names(dat %>% select(comorbilidad_psiquiatrica,pe_intensidad_d ))
dat %<>% mutate_at(vars(var_num), var_to_num)
```



### Variables FACTOR

<div id="factor_ueb" style="border: 1px solid #ddd; padding: 10px; border-radius: 5px; background-color: #d1ebd3;">
**factor_ueb**

Esta función conserva las etiqueta de la variable original y permite ordenar y asignar valores a los distintos niveles de la variable.
</div>


Preprocesados habituales para este tipo de variable:

- **Transformación de distintas variables a factor**: Seleccionamos todas las variables que queremos transformar y usando la función propia factor_ueb. 

```{r}
var_fac <- names(dat %>% select(treatment, hospital))
dat[,var_fac] <- lapply(dat[,var_fac], function(x) factor_ueb(x, name.var = names(dat[,var_fac])[parent.frame()$i[]]))
```


- **Asignación de etiquetas**: Cuando una variable tiene formato númerico es necesario indicar a cada uno de los niveles una etiqueta. 

```{r}
table(dat$smoker)
dat %<>% mutate(smoker = factor_ueb(smoker, levs = c(0:1),labs = c("No", "Sí"))) 
table(dat$smoker)
```


- **Reordenar etiquetas**: Cuando se quieren reordenar los niveles de la variable

```{r}
table(dat$hospital)
dat %<>% mutate(hospital = factor_ueb(hospital,labs = c("Hospital 2", "Hospital 1",  "Unknown")))
table(dat$hospital)
```




- **REasignación de etiquetas**: En algunos casos una misma etiqueta clínica viene con distintas escrituras. P.e Sí Si. Reasignamos categorías y verificamos que no hemos perdido información


```{r}
table(dat$diabetes)

dat %<>% mutate(diabetes = factor_ueb(diabetes, levs = c("N",  "1", "0" ,"Y" ,"No","Yes"),
                                                labs = c("No", "Sí","No","Sí","No","Sí"))) 
table(dat$diabetes)

list_changes[[length(list_changes)]]
```


- **Asignación múltiple de etiquetas**: Cuando necesitamos reasignar los niveles a etiquetas para múltiples variables, y estos niveles y etiquetas son idénticos, se puede automatizar el proceso de la siguiente manera.  <span style="color: red;">**Es imprescindible indicar las variables en el vector 'var_sino' y verificar los levs y los labs**</span>


```{r}
var_sino <- names(dat %>% select(sust_edss30,sust_edss40))
dat[,var_sino] <- lapply(dat[,var_sino], function(x) factor_ueb(x, levs = c(0,1), labs = c("VerificarNo" ,"VerificarSi"),
 name.var = names(dat[,var_sino])[parent.frame()$i[]]))
desc_changes(paste0("Los valores '0' y '1' de las variables", paste0(var_sino, collapse =  ", ")," han sido etiquetados como 'No' y 'Si'."))

```



### Variables CARACTER

Seleccionamos variables que deseamos transformar a carácter en el vector 'var_char' y transformamos automáticamente todas las variables a caracter. 

```{r}
var_char <- names(dat %>% select(id))
dat <- dat %>% mutate_at(var_char,as.character.ueb)
```

<div id="as.character.ueb" style="width: 80%; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background-color: #d1ebd3;">
**as.character.ueb**

se utiliza para convertir una variable del tipo que sea a carácter conservando la etiqueta del nombre. 

</div>


### Creación de nuevas variables


#### Transformaciones variables numericas

```{r}

# var_1000000 <- names(dat %>% select(contains("human"), - ppm1l_human, -catc_human))
# dat %<>%
#   mutate(across(var_1000000, ~ . / 1000000)) %>% 
# 
# desc_changes(paste("Las variables", paste(var_1000000, collapse = ", "), "han sido divididas entre 1000000 para facilitar el ajuste de modelos y posterior interpretación" ))

```






### Eliminación de variables 

Es común que, entre las variables disponibles en la base de datos, algunas no se utilicen, ya sea porque una gran parte de los individuos carece de información en dichas variables o porque no resultan relevantes para el estudio.

En el primer caso, se puede automatizar teniendo en un cuenta un máximo porcentaje de información faltante. En el código que se muestra a continuación se considera el 95%. Este código se puede ejecutar directamente siempre y cuando el nombre del data.frame sea 'dat'

```{r eliminem variables}
##################
#### Eliminem variables que no s'utilitzen 
##################
var_del <- NAperc(dat, maxNA = 95)$var ## seleccionem variables amb un 95% de dades faltants
dat <- dat %>% select(-var_del)

```

También se pueden eliminar variables de forma manual, cuando los investigadores nos dan instrucciones para ello: 


```{r}
dat %<>% select(-subgrupo_ab, -contains("comentarios")) 
```

<span style="color:red"> **Importante: FUNCION DESC_CHANGES ** </span>





## Específico Redcap longitudinal

### Rellenar grupo

En REDCap, cuando se exportan datos longitudinales (con múltiples eventos o visitas), la variable que indica el grupo al que fue asignado el paciente (por ejemplo, "Grupo Intervención" o "Grupo Control") suele estar disponible solo en el evento basal. Para los eventos de seguimiento (por ejemplo, "Visita 6 meses" o "Visita 12 meses"), esta información puede aparecer como NA o vacía. Para solucionar esto, podemos propagar la información del grupo desde el evento basal a todos los eventos de seguimiento.


Es imprescindible modificar el nombre de la variable <span style="color:red"> **grupo** </span> en el caso de que 'grupo' no sea el nombre de la variable grupo. 

```{r}
dat <- dat %>%
  group_by(id) %>%  # Agrupar por sujeto
  fill(grupo, .direction = "downup") %>% 
  as.data.frame()

```


### Eliminación de variables

Habitualmente en Redcap habra una serie de variables que no serán usadas para el análisis, estas son aquellas que indican si el cuestionario esta completo y comentarios. El código para eliminarlas es el siguiente.

```{r}
dat %<>% select( -contains("comentarios"), -ends_with("_complete")) 
```



### Separación datos basales y longitudinales

Para seleccionar las variables basales de forma automática se puede hacer de la siguiente manera. 

Es imprescindible modificar el nombre de la <span style="color:red"> **"Visita Basal"** </span> por el nombre que tenga el evento 0 en Redcap (habitualmente se encuentra en la variable redcap_event_name)

```{r}

# Filtramos los datos que no son de la visita basal
dat_no_basales <- subset(dat, redcap_event_name != "Visita Basal")

# Identificamos columnas que solo tienen valores en la visita basal
variables_basales <- sapply(names(dat), function(col) {
  all(is.na(dat_no_basales[[col]]))  # TRUE si solo tiene valores en basal
})
var_bas <- names(variables_basales[variables_basales])
rm(dat_no_basales)

dat_bas <- dat %>% select(var_bas, grupo)
```




## Exportación de los datos

Una vez preparados los datos para el análisis, es posible guardarlos en un archivo de Excel, R o en el formato que se desee. Se recomienda ejecutar este paso de manera puntual, es decir, no cada vez que se compile el documento RMarkdown (rmd), para evitar reprocesamientos innecesarios y optimizar el flujo de trabajo.

```{r}
name_ana_dat <- paste0("ana_dades_XNNNN_", Sys.Date())
rio::export(dat, paste0(file = "dades/", name_ana_dat, ".xlsx")) ## Excel
save(dat, paste0(file = "dades/", name_ana_dat, ".Rda")) ## R
```


## Descripción de los datos 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

```{r}
 desc_data(dat)
```


# Funciones propias

Ver [desc_changes](#desc_changes) para más detalles.

Ver [var_to_num](#var_to_num) para más detalles.

Ver [factor_ueb](#factor_ueb) para más detalles.

Ver [as.character.ueb](#as.character.ueb) para más detalles.



<!-- ## Análisis -->

<!-- ### desc_group -->

<!-- ### desc_numeric -->

<!-- ### desc_mods -->







